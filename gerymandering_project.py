# -*- coding: utf-8 -*-
"""Gerymandering_project_GroupC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IgD4DEMFiuY2x_EuY_66Q5FESDpdKv1Z

# **Fair Map Algorithm**
"""

def generate_fair_map_population_fixed(precinct_df, contiguity_df, num_districts=12, pop_col="Total_2020_TotalAdj"):
    import ast
    import networkx as nx
    import pandas as pd
    import random
    from collections import deque

    G = nx.Graph()
    for _, row in contiguity_df.iterrows():
        precinct = row["Precinct"]
        neighbors = ast.literal_eval(row["Neighbors"])
        for neighbor in neighbors:
            G.add_edge(precinct, neighbor)

    pop_dict = precinct_df.set_index("GEOID20")[pop_col].to_dict()
    total_population = sum(pop_dict.values())
    target_population = total_population / num_districts
    population_limit = target_population * 1.10
    min_population = target_population * 0.90

    all_precincts = set(pop_dict.keys())
    unassigned = set(all_precincts)

    seeds = random.sample(list(unassigned), num_districts)

    assigned = {}
    district_pops = {i: 0 for i in range(1, num_districts + 1)}
    queues = {i: deque() for i in range(1, num_districts + 1)}

    for i, seed in enumerate(seeds, start=1):
        assigned[seed] = i
        district_pops[i] += pop_dict[seed]
        queues[i].append(seed)
        unassigned.remove(seed)

    growing = True
    while growing:
        growing = False
        for district_id in range(1, num_districts + 1):
            if district_pops[district_id] >= population_limit:
                continue
            if not queues[district_id]:
                continue
            current = queues[district_id].popleft()
            for neighbor in G.neighbors(current):
                if neighbor in assigned:
                    continue
                if district_pops[district_id] + pop_dict[neighbor] <= population_limit:
                    assigned[neighbor] = district_id
                    district_pops[district_id] += pop_dict[neighbor]
                    queues[district_id].append(neighbor)
                    unassigned.discard(neighbor)
                    growing = True

    for precinct in list(unassigned):
        for neighbor in G.neighbors(precinct):
            if neighbor in assigned:
                district_id = assigned[neighbor]
                assigned[precinct] = district_id
                district_pops[district_id] += pop_dict[precinct]
                break

    return pd.DataFrame(list(assigned.items()), columns=["GEOID20", "District"])

fair_map = generate_fair_map_population_fixed(precinct_df, contiguity_df)



fair_map.to_csv("/content/drive/MyDrive/Gerrymandering Project - Group C/Fairmap.csv", index=False)

"""# **Unfair Map Algorithm**"""

import pandas as pd
import random
import ast



def get_neighbors(precinct, contiguity_df):

    row = contiguity_df[contiguity_df['Precinct'] == precinct]
    if row.empty:
        return []
    try:
        return ast.literal_eval(row['Neighbors'].values[0])
    except Exception:
        return []



def build_balanced_map():
    precinct_df = pd.read_csv("precinct-data-congress-nj.csv")
    contiguity_df = pd.read_csv("Contiguity_nj.csv", header=None)
    contiguity_df.columns = ["Precinct", "Neighbors"]

    pop_data = {}
    for _, row in precinct_df.iterrows():
        pop_data[row["GEOID20"]] = row["Total_2020_Total"]

    total_pop = sum(pop_data.values())
    num_districts = 12
    ideal_pop = total_pop / num_districts


    seeds = {}
    init_assignment_file = "precinct-assignments-congress-nj (1).csv"
    try:
        init_df = pd.read_csv(init_assignment_file)
        for d in range(1, num_districts+1):
            sub_df = init_df[init_df["District"] == d]
            if not sub_df.empty:
                seeds[d] = sub_df["GEOID20"].iloc[0]
        if len(seeds) < num_districts:
            raise Exception("There is Not enough seeds from the initial assignment.")
    except Exception as e:
        all_precincts = precinct_df["GEOID20"].tolist()
        random.shuffle(all_precincts)
        for d in range(1, num_districts+1):
            seeds[d] = all_precincts[d-1]

    assignment = {}
    district_pop = {}
    frontier = {}
    assigned = set()

    for d in range(1, num_districts+1):
        seed = seeds[d]
        assignment[seed] = d
        district_pop[d] = pop_data[seed]
        assigned.add(seed)
        frontier[d] = set(get_neighbors(seed, contiguity_df))

    all_precincts = set(precinct_df["GEOID20"].tolist())
    unassigned = all_precincts - assigned


    while unassigned:
        districts_order = sorted(range(1, num_districts+1), key=lambda d: district_pop[d])
        expansion_occurred = False

        for d in districts_order:
            valid_candidates = frontier[d] & unassigned
            if not valid_candidates:
                continue

            best_candidate = None
            best_diff = float('inf')
            for p in valid_candidates:
                new_pop = district_pop[d] + pop_data[p]
                diff = abs(new_pop - ideal_pop)
                if diff < best_diff:
                    best_diff = diff
                    best_candidate = p

            if best_candidate is not None:
                assignment[best_candidate] = d
                district_pop[d] += pop_data[best_candidate]
                assigned.add(best_candidate)
                unassigned.remove(best_candidate)
                expansion_occurred = True
                for d2 in frontier:
                    frontier[d2].discard(best_candidate)
                for nbr in get_neighbors(best_candidate, contiguity_df):
                    if nbr in unassigned:
                        frontier[d].add(nbr)

        if not expansion_occurred:
            break

    for p in list(unassigned):
        nbrs = get_neighbors(p, contiguity_df)
        assigned_nbr = [assignment[n] for n in nbrs if n in assignment]
        if assigned_nbr:
            from collections import Counter
            c = Counter(assigned_nbr)
            d_chosen = c.most_common(1)[0][0]
            assignment[p] = d_chosen
            district_pop[d_chosen] += pop_data[p]
            unassigned.remove(p)
        else:
            d_chosen = min(district_pop, key=lambda d: district_pop[d])
            assignment[p] = d_chosen
            district_pop[d_chosen] += pop_data[p]
            unassigned.remove(p)


    return assignment, district_pop, ideal_pop

if __name__ == "__main__":
    assignment, district_pop, ideal = build_balanced_map()

    out_df = pd.DataFrame(list(assignment.items()), columns=["GEOID20", "District"])
    out_df.to_csv("/content/drive/MyDrive/Gerrymandering Project - Group C/Unfairmap.csv", index=False)